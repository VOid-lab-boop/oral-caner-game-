<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Oral Health Runner - Cancer Awareness Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            transition: filter 0.1s;
        }

        #gameContainer.shake {
            animation: shake 0.3s;
        }

        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -5px); }
        }

        @keyframes flash-red {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(255, 0, 0, 0.3); }
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-element {
            pointer-events: auto;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .game-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 48px;
            border-radius: 12px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            border: none;
            transition: all 0.3s;
            animation: pulse 2s infinite;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.6);
        }

        .health-bad { color: #ef4444; }
        .health-warning { color: #f59e0b; }
        .health-good { color: #10b981; }

        .hidden { display: none !important; }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 200;
        }

        .modal-box {
            background: white;
            border-radius: 24px;
            padding: 48px;
            max-width: 700px;
            width: 90%;
            text-align: center;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-box h1 {
            font-size: clamp(1.8rem, 6vw, 3rem);
            font-weight: 900;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
        }

        .credits {
            margin: 16px 0 24px 0;
            padding: 16px;
            background: linear-gradient(135deg, #f0f0f0 0%, #e8e8e8 100%);
            border-radius: 12px;
            border: 2px solid #667eea;
        }

        .credits .dev {
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 900;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .credits .ideas {
            font-size: clamp(14px, 3vw, 16px);
            font-weight: 600;
            color: #34495e;
        }

        .modal-box p {
            color: #555;
            font-size: clamp(14px, 3.5vw, 18px);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .catalogue {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin: 24px 0;
            text-align: left;
        }

        .catalogue-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 12px;
            border: 2px solid #e9ecef;
            transition: transform 0.2s;
        }

        .catalogue-item:hover {
            transform: translateY(-4px);
        }

        .catalogue-item.good {
            border-color: #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .catalogue-item.bad {
            border-color: #ef4444;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        }

        .catalogue-item h3 {
            font-size: 16px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .catalogue-item p {
            font-size: 13px;
            margin: 0;
        }

        .catalogue-item .effect {
            font-weight: bold;
            margin-top: 4px;
        }

        #catalogue-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all 0.3s;
        }

        #catalogue-toggle:hover {
            transform: scale(1.1) rotate(10deg);
        }

        #catalogue-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            padding: 20px;
            max-width: 350px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            max-height: 70vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
        }

        #catalogue-panel h3 {
            margin-top: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 18px;
            margin-bottom: 16px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 12px 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: inline-block;
            margin: 4px;
        }

        .stat-label {
            color: #666;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #000;
        }

        .combo-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5);
            animation: comboAnimation 0.5s ease-out;
            pointer-events: none;
            z-index: 1000;
        }

        @keyframes comboAnimation {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        .achievement {
            position: fixed;
            top: 100px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.5s ease-out, slideOut 0.5s ease-in 2.5s;
            z-index: 500;
            font-weight: 700;
        }

        @keyframes slideOut {
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .health-bar-container {
            width: 100%;
            /* MODIFIED: Reduced height from 16px to 10px */
            height: 10px; 
            background: #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
            margin-top: 4px;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
            transition: width 0.3s, background 0.3s;
            border-radius: 8px;
        }

        .health-bar.warning {
            background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        }

        .health-bar.bad {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
        }

        @media (max-width: 768px) {
            .modal-box {
                padding: 24px;
            }

            .stat-card {
                padding: 8px 16px;
                margin: 2px;
            }

            .stat-value {
                font-size: 20px;
            }

            #catalogue-panel {
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .catalogue {
                grid-template-columns: 1fr;
            }

            .combo-display {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <div class="modal-box">
            <h1>ü¶∑ Oral Health Runner</h1>

            <div class="credits">
                <div class="dev">üíª <strong>Developed by Yaman Akour</strong></div>
                <div class="ideas">üí° Idea contribution: Ameer Frehat</div>
            </div>

            <p>
                Run and collect <strong>healthy items</strong> while avoiding <strong>harmful ones</strong>.
                Your mouth will grow larger when you consume bad items - simulating <strong>oral cancer progression</strong>.
            </p>

            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); padding: 16px; border-radius: 12px; margin: 20px 0; border: 2px solid #f59e0b;">
                <h3 style="color: #92400e; margin: 0 0 8px 0;">üéÆ NEW FEATURES!</h3>
                <ul style="text-align: left; color: #78350f; font-size: 14px; margin: 0; padding-left: 20px;">
                    <li>üî• <strong>Combo System</strong> - Chain good items for bonus points!</li>
                    <li>üèÜ <strong>Achievements</strong> - Unlock special milestones!</li>
                    <li>‚≠ê <strong>Score System</strong> - Compete for high scores!</li>
                    <li>üí® <strong>Dynamic Speed</strong> - Speed changes with health!</li>
                    <li>‚ú® <strong>Visual Effects</strong> - Particles & screen shake!</li>
                    <li>üå≥ <strong>3D Scenery</strong> - Trees, clouds & buildings!</li>
                </ul>
            </div>

            <h2 style="color: #10b981; margin: 24px 0 16px 0; font-size: 1.4rem;">‚úÖ Good for Your Health</h2>
            <div class="catalogue">
                <div class="catalogue-item good">
                    <h3>üçé Fruits</h3>
                    <p class="effect">+15% Health</p>
                    <p>Vitamins & fiber</p>
                </div>
                <div class="catalogue-item good">
                    <h3>ü•¶ Vegetables</h3>
                    <p class="effect">+15% Health</p>
                    <p>Nutrients & minerals</p>
                </div>
                <div class="catalogue-item good">
                    <h3>ü™• Toothbrush</h3>
                    <p class="effect">+20% Health</p>
                    <p>Clean teeth!</p>
                </div>
                <div class="catalogue-item good">
                    <h3>üíß Water</h3>
                    <p class="effect">+10% Health</p>
                    <p>Hydration</p>
                </div>
            </div>

            <h2 style="color: #ef4444; margin: 24px 0 16px 0; font-size: 1.4rem;">‚ùå Bad for Your Health</h2>
            <div class="catalogue">
                <div class="catalogue-item bad">
                    <h3>üö¨ Cigarette</h3>
                    <p class="effect">**-30%** Health</p>
                    <p>Major cancer risk!</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üçî Fast Food</h3>
                    <p class="effect">**-25%** Health</p>
                    <p>Unhealthy fats</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üç´ Chocolate</h3>
                    <p class="effect">**-15%** Health</p>
                    <p>Sugar & cavities</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>ü•§ Soda</h3>
                    <p class="effect">**-18%** Health</p>
                    <p>Acids erode teeth</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üç¨ Candy</h3>
                    <p class="effect">**-15%** Health</p>
                    <p>Pure sugar</p>
                </div>
            </div>

            <p style="color: #ef4444; font-weight: 700; margin-top: 24px;">
                ‚ö†Ô∏è **3** bad items in a row = Immediate Game Over!
            </p>
            <button onclick="startGame()" class="game-button">
                üéÆ Start Game
            </button>
        </div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer"></div>

    <!-- UI Overlay -->
    <div id="ui">
        <!-- Catalogue Toggle Button -->
        <button id="catalogue-toggle" class="hidden ui-element" onclick="toggleCatalogue()" title="Item Guide">üìñ</button>

        <!-- Catalogue Panel -->
        <div id="catalogue-panel" class="hidden ui-element">
            <h3>üìñ Item Guide</h3>
            <div class="catalogue">
                <div class="catalogue-item good">
                    <h3>üçé Fruits</h3>
                    <p class="effect">+15%</p>
                </div>
                <div class="catalogue-item good">
                    <h3>ü•¶ Vegetables</h3>
                    <p class="effect">+15%</p>
                </div>
                <div class="catalogue-item good">
                    <h3>ü™• Toothbrush</h3>
                    <p class="effect">+20%</p>
                </div>
                <div class="catalogue-item good">
                    <h3>üíß Water</h3>
                    <p class="effect">+10%</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üö¨ Cigarette</h3>
                    <p class="effect">-30%</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üçî Fast Food</h3>
                    <p class="effect">-25%</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üç´ Chocolate</h3>
                    <p class="effect">-15%</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>ü•§ Soda</h3>
                    <p class="effect">-18%</p>
                </div>
                <div class="catalogue-item bad">
                    <h3>üç¨ Candy</h3>
                    <p class="effect">-15%</p>
                </div>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden ui-element" style="position: absolute; top: 20px; left: 20px;">
            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                <div class="stat-card">
                    <div class="stat-label">‚è±Ô∏è Time</div>
                    <div id="timer" class="stat-value">0s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">üíØ Score</div>
                    <div id="score" class="stat-value" style="color: #667eea;">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">üî• Combo</div>
                    <div id="combo" class="stat-value" style="color: #f59e0b;">0x</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">‚ö° Streak</div>
                    <div id="streak" class="stat-value" style="color: #ef4444;">0/3</div>
                </div>
            </div>
            <div class="stat-card" style="margin-top: 12px; display: block; min-width: 180px;">
                <div class="stat-label">‚ù§Ô∏è Health</div>
                <div id="health" class="health-good" style="font-size: 16px; font-weight: bold; margin-bottom: 2px;">100%</div>
                <div class="health-bar-container">
                    <div id="healthBar" class="health-bar" style="width: 100%;"></div>
                </div>
            </div>
        </div>

        <!-- Instructions -->
        <div id="instructions" class="hidden ui-element" style="position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%);">
            <div style="background: rgba(255,255,255,0.95); border-radius: 16px; padding: 16px 32px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                <p style="font-weight: 700; margin-bottom: 8px; font-size: 16px; color: #000;">Use Arrow Keys ‚¨ÖÔ∏è ‚û°Ô∏è or Swipe to Move</p>
                <p style="font-size: 14px; color: #666; margin: 0;">Collect healthy items, avoid harmful ones!</p>
            </div>
        </div>

        <!-- Game Over -->
        <!-- FIX: Added pointer-events: auto to ensure the button is clickable on touch devices -->
        <div id="gameOverScreen" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; z-index: 300; pointer-events: auto;">
            <div class="modal-box">
                <h2 id="gameOverTitle" style="font-size: 2.5rem; font-weight: bold; margin-bottom: 24px;"></h2>
                <p id="gameOverMessage" style="color: #555; font-size: 18px; margin-bottom: 32px;"></p>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-bottom: 32px;">
                    <div style="background: #f5f5f5; border-radius: 12px; padding: 20px;">
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">Final Health</div>
                        <div id="finalHealth" style="font-size: 36px; font-weight: bold;"></div>
                    </div>
                    <div style="background: #f5f5f5; border-radius: 12px; padding: 20px;">
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">Final Score</div>
                        <div id="finalScore" style="font-size: 36px; font-weight: bold; color: #667eea;">0</div>
                    </div>
                    <div style="background: #f5f5f5; border-radius: 12px; padding: 20px;">
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">Max Combo</div>
                        <div id="maxCombo" style="font-size: 36px; font-weight: bold; color: #f59e0b;">0x</div>
                    </div>
                </div>
                <div id="achievements" style="margin-bottom: 24px;"></div>
                <button onclick="restartGame()" class="game-button">
                    üîÑ Play Again
                </button>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, player, items = [], particles = [], sceneryObjects = [];
        let gameRunning = false;
        let health = 100, badStreak = 0, goodStreak = 0, gameTime = 0;
        let score = 0, combo = 0, maxCombo = 0;
        let currentLane = 1, lastSpawnTime = 0;
        let catalogueOpen = false;
        let achievements = [];
        let baseSpeed = 0.25; // Start slower
        let baseSpawnInterval = 1.5; // Start with slower spawn
        let SPAWN_INTERVAL = 1.5; // Dynamic spawn interval

        const LANE_WIDTH = 2.5;
        const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const BAD_STREAK_LIMIT = 3;

        const ITEM_TYPES = {
            fruit: { color: 0xff4444, health: 15, points: 10 },
            vegetable: { color: 0x22aa22, health: 15, points: 10 },
            toothbrush: { color: 0x3b82f6, health: 20, points: 15 },
            water: { color: 0x4dd0e1, health: 10, points: 8 },
            // MODIFIED: Increased negative health values (damage)
            cigarette: { color: 0xef4444, health: -30, points: 0 }, 
            fastfood: { color: 0xf59e0b, health: -25, points: 0 }, 
            chocolate: { color: 0x8B4513, health: -15, points: 0 }, 
            soda: { color: 0xff1744, health: -18, points: 0 }, 
            candy: { color: 0xff69b4, health: -15, points: 0 }
        };

        // --- NEW/MODIFIED CONSTANTS FOR SPAWNING ---
        // MODIFIED: Fixed bad item probability to 75% for 3:1 ratio (3 bad / 1 good)
        const BAD_ITEM_PROBABILITY_RATIO = 0.75; // 3 / (3 + 1) = 0.75
        const MAX_MOUTH_SCALE = 2.0; 
        const MOUTH_GROWTH_RATE_PER_BAD_ITEM = 0.03; 
        const DIFFICULTY_MAX_TIME = 60; // Still used for speed ramp-up

        // Weights for Bad Items (Higher weight = spawns more often)
        const BAD_ITEM_WEIGHTS = {
            cigarette: 3,
            fastfood: 2,
            chocolate: 1,
            soda: 1.5, // Slightly more soda than candy/chocolate
            candy: 1
        };

        // --- END NEW/MODIFIED CONSTANTS ---

        const ACHIEVEMENTS_LIST = [
            { id: 'first_healthy', name: 'üçé Health Conscious', desc: 'Collect your first healthy item', check: () => goodStreak >= 1 },
            { id: 'combo_3', name: 'üî• 3x Combo', desc: 'Achieve a 3x combo', check: () => combo >= 3 },
            { id: 'combo_5', name: 'üí• 5x Combo Master', desc: 'Achieve a 5x combo', check: () => combo >= 5 },
            { id: 'score_100', name: 'üíØ Century', desc: 'Score 100 points', check: () => score >= 100 },
            { id: 'score_250', name: '‚≠ê Star Player', desc: 'Score 250 points', check: () => score >= 250 },
            { id: 'score_500', name: 'üåü Superstar', desc: 'Score 500 points', check: () => score >= 500 },
            { id: 'perfect_health', name: '‚ù§Ô∏è Perfect Health', desc: 'Maintain 100% health for 30 seconds', check: () => health === 100 && gameTime >= 30 }
        ];

        function toggleCatalogue() {
            catalogueOpen = !catalogueOpen;
            const panel = document.getElementById('catalogue-panel');
            if (catalogueOpen) {
                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
        }

        function showCombo(multiplier) {
            const comboEl = document.createElement('div');
            comboEl.className = 'combo-display';
            comboEl.textContent = `${multiplier}x COMBO!`;
            document.body.appendChild(comboEl);
            setTimeout(() => comboEl.remove(), 500);
        }

        function showAchievement(achievement) {
            const achEl = document.createElement('div');
            achEl.className = 'achievement';
            achEl.innerHTML = `<div style="font-size: 20px; margin-bottom: 4px;">${achievement.name}</div><div style="font-size: 14px; opacity: 0.9;">${achievement.desc}</div>`;
            document.body.appendChild(achEl);
            setTimeout(() => achEl.remove(), 3000);
        }

        function checkAchievements() {
            ACHIEVEMENTS_LIST.forEach(ach => {
                if (!achievements.includes(ach.id) && ach.check()) {
                    achievements.push(ach.id);
                    showAchievement(ach);
                }
            });
        }

        function createParticle(x, y, z, color, isGood) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(x, y, z);

            particle.userData.velocity = {
                x: (Math.random() - 0.5) * 0.2,
                y: Math.random() * 0.3 + 0.2,
                z: (Math.random() - 0.5) * 0.2
            };
            particle.userData.lifetime = 1.0;

            scene.add(particle);
            particles.push(particle);
        }

        function createParticleExplosion(x, y, z, isGood) {
            const color = isGood ? 0xffd700 : 0xff0000;
            for (let i = 0; i < 10; i++) {
                createParticle(x, y, z, color, isGood);
            }
        }

        function screenShake() {
            const container = document.getElementById('gameContainer');
            container.classList.add('shake');
            setTimeout(() => container.classList.remove('shake'), 300);
        }

        function flashScreen() {
            const container = document.getElementById('gameContainer');
            container.style.animation = 'flash-red 0.3s';
            setTimeout(() => container.style.animation = '', 300);
        }

        function init3D() {
            scene = new THREE.Scene();

            // Sky gradient
            const skyColor = new THREE.Color(0x87CEEB);
            const horizonColor = new THREE.Color(0xffe4b5);
            scene.background = skyColor;
            scene.fog = new THREE.Fog(horizonColor, 20, 80);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 6, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -30;
            sunLight.shadow.camera.right = 30;
            sunLight.shadow.camera.top = 30;
            sunLight.shadow.camera.bottom = -30;
            scene.add(sunLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Road
            for (let i = 0; i < 60; i++) {
                const roadGeo = new THREE.PlaneGeometry(8, 3);
                const roadMat = new THREE.MeshStandardMaterial({
                    color: i % 2 === 0 ? 0x2a2a2a : 0x353535,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const road = new THREE.Mesh(roadGeo, roadMat);
                road.rotation.x = -Math.PI / 2;
                road.position.set(0, 0.01, -i * 3);
                road.receiveShadow = true;
                road.userData.isRoad = true;
                scene.add(road);
            }

            // Lane lines
            for (let lane = 0; lane < 2; lane++) {
                for (let i = 0; i < 80; i++) {
                    const lineGeo = new THREE.BoxGeometry(0.15, 0.1, 1);
                    const lineMat = new THREE.MeshStandardMaterial({
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.4
                    });
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.position.set(LANES[lane] + LANE_WIDTH / 2, 0.05, -i * 2.5);
                    line.userData.isLine = true;
                    scene.add(line);
                }
            }

            createScenery();
            createPlayer();

            // Events
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.addEventListener('keydown', (e) => {
                if (!gameRunning) return;
                if (e.key === 'ArrowLeft' && currentLane > 0) currentLane--;
                if (e.key === 'ArrowRight' && currentLane < 2) currentLane++;
            });

            let touchStartX = 0;
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
            });
            document.addEventListener('touchend', (e) => {
                if (!gameRunning) return;
                const diff = e.changedTouches[0].clientX - touchStartX;
                if (Math.abs(diff) < 30) {
                    // Small tap/release
                    // Tap on the right half to move right, left half to move left (Optional control scheme)
                    // We'll stick to swipe logic for now, but this block is good for future expansion.
                } else if (Math.abs(diff) > 50) {
                    if (diff > 0 && currentLane < 2) currentLane++;
                    else if (diff < 0 && currentLane > 0) currentLane--;
                }
            });

            animate();
        }

        function createScenery() {
            // Trees on sides
            for (let i = 0; i < 30; i++) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const x = side * (8 + Math.random() * 5);
                const z = -i * 6 - Math.random() * 5;

                // Tree trunk
                const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.set(x, 1.5, z);
                trunk.castShadow = true;
                trunk.userData.isScenery = true;
                scene.add(trunk);
                sceneryObjects.push(trunk);

                // Tree crown
                const crownGeo = new THREE.ConeGeometry(1.5, 3, 8);
                const crownMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
                const crown = new THREE.Mesh(crownGeo, crownMat);
                crown.position.set(x, 4.5, z);
                crown.castShadow = true;
                crown.userData.isScenery = true;
                scene.add(crown);
                sceneryObjects.push(crown);
            }

            // Clouds
            for (let i = 0; i < 15; i++) {
                const cloudGroup = new THREE.Group();
                for (let j = 0; j < 3; j++) {
                    const cloudGeo = new THREE.SphereGeometry(1 + Math.random(), 8, 8);
                    const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                    const cloud = new THREE.Mesh(cloudGeo, cloudMat);
                    cloud.position.set(j * 1.5 - 1.5, 0, 0);
                    cloudGroup.add(cloud);
                }
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 60,
                    15 + Math.random() * 10,
                    -Math.random() * 100 - 20
                );
                cloudGroup.userData.isCloud = true;
                scene.add(cloudGroup);
                sceneryObjects.push(cloudGroup);
            }

            // Buildings in far distance
            for (let i = 0; i < 10; i++) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const buildingGeo = new THREE.BoxGeometry(
                    2 + Math.random() * 2,
                    5 + Math.random() * 10,
                    2 + Math.random() * 2
                );
                const buildingMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.6, 0.3, 0.4 + Math.random() * 0.2),
                    roughness: 0.7
                });
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.set(
                    side * (20 + Math.random() * 20),
                    building.geometry.parameters.height / 2,
                    -50 - Math.random() * 50
                );
                building.castShadow = true;
                building.userData.isBuilding = true;
                scene.add(building);
                sceneryObjects.push(building);
            }
        }

        function createPlayer() {
            player = new THREE.Group();

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.9, 12);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });

            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.2, -0.45, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.2, -0.45, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);

            // Torso
            const torsoGeo = new THREE.BoxGeometry(0.8, 1.0, 0.4);
            const torsoMat = new THREE.MeshStandardMaterial({ color: 0x3498db });
            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.position.y = 0.5;
            torso.castShadow = true;
            player.add(torso);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 12);
            const armMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });

            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.5, 0.4, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.5, 0.4, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            player.add(rightArm);

            // Neck
            const neckGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 12);
            const neckMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const neck = new THREE.Mesh(neckGeo, neckMat);
            neck.position.y = 1.1;
            neck.castShadow = true;
            player.add(neck);

            // Head
            const headGeo = new THREE.SphereGeometry(0.35, 24, 24);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.45;
            head.castShadow = true;
            player.add(head);

            // Hair
            const hairGeo = new THREE.SphereGeometry(0.37, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x2c1810 });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 1.6;
            hair.castShadow = true;
            player.add(hair);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.08, 12, 12);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.12, 1.5, 0.3);
            player.add(leftEye);

            const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), pupilMat);
            leftPupil.position.set(-0.12, 1.5, 0.36);
            player.add(leftPupil);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.12, 1.5, 0.3);
            player.add(rightEye);

            const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), pupilMat);
            rightPupil.position.set(0.12, 1.5, 0.36);
            player.add(rightPupil);

            // Nose
            const noseGeo = new THREE.ConeGeometry(0.06, 0.12, 8);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.set(0, 1.4, 0.35);
            nose.rotation.x = Math.PI / 2;
            player.add(nose);

            // Mouth (will grow/shrink)
            const mouthGeo = new THREE.SphereGeometry(0.18, 16, 16);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 1.25, 0.32);
            mouth.scale.set(1.2, 0.5, 0.6);
            player.add(mouth);
            player.userData.mouth = mouth;
            player.userData.mouthScale = 1;

            player.position.set(0, 0.9, 3);
            scene.add(player);
        }

        // Item creation functions (same as before)
        function createFruit() {
            const group = new THREE.Group();
            // Simple clean apple
            const appleGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const appleMat = new THREE.MeshToonMaterial({ color: 0xff0000 });
            const apple = new THREE.Mesh(appleGeo, appleMat);
            apple.scale.set(1, 0.9, 1);
            apple.castShadow = true;
            group.add(apple);

            // Simple stem
            const stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8);
            const stemMat = new THREE.MeshToonMaterial({ color: 0x654321 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.35;
            group.add(stem);

            // Simple leaf
            const leafGeo = new THREE.CircleGeometry(0.12, 8);
            const leafMat = new THREE.MeshToonMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.set(0.1, 0.4, 0);
            leaf.rotation.y = Math.PI / 4;
            group.add(leaf);

            return group;
        }

        function createVegetable() {
            const group = new THREE.Group();
            // Simple broccoli with spheres
            const crownMat = new THREE.MeshToonMaterial({ color: 0x228b22 });

            // Center top
            const top = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), crownMat);
            top.position.y = 0.25;
            top.castShadow = true;
            group.add(top);

            // Surrounding florets
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const floret = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12), crownMat);
                floret.position.set(Math.cos(angle) * 0.15, 0.12, Math.sin(angle) * 0.15);
                floret.castShadow = true;
                group.add(floret);
            }

            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.35, 8);
            const stemMat = new THREE.MeshToonMaterial({ color: 0x90EE90 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = -0.15;
            stem.castShadow = true;
            group.add(stem);

            return group;
        }

        function createToothbrush() {
            const group = new THREE.Group();
            // Simple toothbrush
            const handleGeo = new THREE.BoxGeometry(0.8, 0.1, 0.08);
            const handleMat = new THREE.MeshToonMaterial({ color: 0x2196F3 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.castShadow = true;
            group.add(handle);

            // Brush head
            const headGeo = new THREE.BoxGeometry(0.25, 0.12, 0.1);
            const headMat = new THREE.MeshToonMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.x = 0.52;
            head.castShadow = true;
            group.add(head);

            // Bristles
            const bristleMat = new THREE.MeshToonMaterial({ color: 0x00ffff });
            for (let i = 0; i < 5; i++) {
                const bristleGeo = new THREE.BoxGeometry(0.03, 0.1, 0.03);
                const bristle = new THREE.Mesh(bristleGeo, bristleMat);
                bristle.position.set(0.44 + i * 0.04, 0.11, 0);
                group.add(bristle);
            }

            return group;
        }

        function createWater() {
            const group = new THREE.Group();
            // Simple water bottle
            const bottleGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.7, 16);
            const bottleMat = new THREE.MeshToonMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.7
            });
            const bottle = new THREE.Mesh(bottleGeo, bottleMat);
            bottle.castShadow = true;
            group.add(bottle);

            // Cap
            const capGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.15, 16);
            const capMat = new THREE.MeshToonMaterial({ color: 0x1976D2 });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 0.42;
            cap.castShadow = true;
            group.add(cap);

            return group;
        }

        function createCigarette() {
            const group = new THREE.Group();
            // Simple cigarette
            const bodyGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 12);
            const bodyMat = new THREE.MeshToonMaterial({ color: 0xffffff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.z = Math.PI / 4;
            body.castShadow = true;
            group.add(body);

            // Filter
            const filterGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.2, 12);
            const filterMat = new THREE.MeshToonMaterial({ color: 0xD2691E });
            const filter = new THREE.Mesh(filterGeo, filterMat);
            filter.position.set(-0.42, -0.07, 0);
            filter.rotation.z = Math.PI / 4;
            group.add(filter);

            // Burning tip
            const tipGeo = new THREE.SphereGeometry(0.08, 12, 12);
            const tipMat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.position.set(0.42, 0.07, 0);
            group.add(tip);

            return group;
        }

        function createFastFood() {
            const group = new THREE.Group();
            // Simple burger
            const bunMat = new THREE.MeshToonMaterial({ color: 0xF4A460 });

            // Bottom bun
            const bottomBun = new THREE.Mesh(new THREE.CylinderGeometry(0.32, 0.28, 0.12, 16), bunMat);
            bottomBun.position.y = -0.2;
            bottomBun.castShadow = true;
            group.add(bottomBun);

            // Patty
            const pattyGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
            const pattyMat = new THREE.MeshToonMaterial({ color: 0x654321 });
            const patty = new THREE.Mesh(pattyGeo, pattyMat);
            patty.position.y = -0.08;
            patty.castShadow = true;
            group.add(patty);

            // Cheese
            const cheeseGeo = new THREE.CylinderGeometry(0.32, 0.32, 0.04, 16);
            const cheeseMat = new THREE.MeshToonMaterial({ color: 0xFFD700 });
            const cheese = new THREE.Mesh(cheeseGeo, cheeseMat);
            cheese.position.y = -0.01;
            group.add(cheese);

            // Lettuce
            const lettuceGeo = new THREE.CylinderGeometry(0.31, 0.31, 0.03, 16);
            const lettuceMat = new THREE.MeshToonMaterial({ color: 0x90EE90 });
            const lettuce = new THREE.Mesh(lettuceGeo, lettuceMat);
            lettuce.position.y = 0.04;
            group.add(lettuce);

            // Top bun
            const topBun = new THREE.Mesh(new THREE.SphereGeometry(0.32, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), bunMat);
            topBun.position.y = 0.15;
            topBun.castShadow = true;
            group.add(topBun);

            return group;
        }

        function createChocolate() {
            const group = new THREE.Group();
            // Simple chocolate bar
            const barGeo = new THREE.BoxGeometry(0.5, 0.15, 0.3);
            const barMat = new THREE.MeshToonMaterial({ color: 0x654321 });
            const bar = new THREE.Mesh(barGeo, barMat);
            bar.castShadow = true;
            group.add(bar);

            return group;
        }

        function createSoda() {
            const group = new THREE.Group();
            // Simple soda can
            const canGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.7, 16);
            const canMat = new THREE.MeshToonMaterial({ color: 0xFF0000 });
            const can = new THREE.Mesh(canGeo, canMat);
            can.castShadow = true;
            group.add(can);

            // Label stripe
            const labelGeo = new THREE.CylinderGeometry(0.19, 0.19, 0.2, 16);
            const labelMat = new THREE.MeshToonMaterial({ color: 0xffffff });
            const label = new THREE.Mesh(labelGeo, labelMat);
            label.position.y = 0.1;
            group.add(label);

            return group;
        }

        function createCandy() {
            const group = new THREE.Group();
            // Simple lollipop with SPHERE (not disc!)
            const stickGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 12);
            const stickMat = new THREE.MeshToonMaterial({ color: 0xffffff });
            const stick = new THREE.Mesh(stickGeo, stickMat);
            stick.position.y = -0.3;
            group.add(stick);

            // SPHERE lollipop candy
            const candyGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const candyMat = new THREE.MeshToonMaterial({ color: 0xFF1493 });
            const candy = new THREE.Mesh(candyGeo, candyMat);
            candy.position.y = 0.05;
            candy.castShadow = true;
            group.add(candy);

            // Simple white spiral stripes
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const stripeGeo = new THREE.BoxGeometry(0.5, 0.05, 0.05);
                const stripeMat = new THREE.MeshToonMaterial({ color: 0xffffff });
                const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                stripe.position.y = 0.05;
                stripe.rotation.y = angle;
                group.add(stripe);
            }

            return group;
        }

        function createItem(type) {
            let itemMesh;

            switch(type) {
                case 'fruit': itemMesh = createFruit(); break;
                case 'vegetable': itemMesh = createVegetable(); break;
                case 'toothbrush': itemMesh = createToothbrush(); break;
                case 'water': itemMesh = createWater(); break;
                case 'cigarette': itemMesh = createCigarette(); break;
                case 'fastfood': itemMesh = createFastFood(); break;
                case 'chocolate': itemMesh = createChocolate(); break;
                case 'soda': itemMesh = createSoda(); break;
                case 'candy': itemMesh = createCandy(); break;
            }

            const lane = LANES[Math.floor(Math.random() * 3)];
            itemMesh.position.set(lane, 0.7, -30);
            itemMesh.userData.type = type;
            itemMesh.userData.collected = false;
            itemMesh.scale.set(1.2, 1.2, 1.2); // Make all items 20% bigger

            scene.add(itemMesh);
            items.push(itemMesh);
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;

                particle.userData.velocity.y -= 0.02;
                particle.userData.lifetime -= delta;

                particle.material.opacity = particle.userData.lifetime;

                if (particle.userData.lifetime <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }

        // Helper function to get a bad item type based on weights
        function getRandomWeightedBadItem() {
            const keys = Object.keys(BAD_ITEM_WEIGHTS);
            const totalWeight = keys.reduce((sum, key) => sum + BAD_ITEM_WEIGHTS[key], 0);
            let random = Math.random() * totalWeight;

            for (const key of keys) {
                if (random < BAD_ITEM_WEIGHTS[key]) {
                    return key;
                }
                random -= BAD_ITEM_WEIGHTS[key];
            }
            // Fallback (shouldn't happen)
            return keys[Math.floor(Math.random() * keys.length)];
        }


        function updateGame(delta) {
            if (!gameRunning) return;

            gameTime += delta;

            // Dynamic speed increases over time - gradual progression
            const timeSpeedMultiplier = 1 + (gameTime / 40); // Speed increases by 100% every 40 seconds
            const healthSpeedMultiplier = 1 + (health / 200);
            const currentSpeed = baseSpeed * timeSpeedMultiplier * healthSpeedMultiplier;

            // Dynamic spawn interval - faster over time
            SPAWN_INTERVAL = Math.max(0.5, baseSpawnInterval - (gameTime / 50)); // Gets faster, min 0.5s

            const targetX = LANES[currentLane];
            player.position.x += (targetX - player.position.x) * 0.15;

            const runSpeed = gameTime * 10;
            player.children.forEach((child, idx) => {
                if (child.geometry && child.geometry.type === 'CylinderGeometry' && child.position.y < 0) {
                    child.rotation.x = Math.sin(runSpeed + idx) * 0.3;
                }
            });

            lastSpawnTime += delta;
            if (lastSpawnTime >= SPAWN_INTERVAL) {
                lastSpawnTime = 0;

                // --- START: Fixed 3:1 Bad to Good Ratio Spawning ---
                const goodTypes = Object.keys(ITEM_TYPES).filter(key => ITEM_TYPES[key].health > 0);

                let itemType;
                // MODIFIED: Use the fixed BAD_ITEM_PROBABILITY_RATIO
                if (Math.random() < BAD_ITEM_PROBABILITY_RATIO) { 
                    // 75% chance to spawn a weighted bad item
                    itemType = getRandomWeightedBadItem();
                } else {
                    // 25% chance to spawn a random good item
                    itemType = goodTypes[Math.floor(Math.random() * goodTypes.length)];
                }
                
                createItem(itemType);
                // --- END: Fixed 3:1 Bad to Good Ratio Spawning ---
            }

            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.position.z += currentSpeed;
                item.rotation.y += 0.05;

                if (!item.userData.collected &&
                    Math.abs(item.position.x - player.position.x) < 0.7 &&
                    Math.abs(item.position.z - player.position.z) < 1.2) {
                    collectItem(item);
                }

                if (item.position.z > 8) {
                    scene.remove(item);
                    items.splice(i, 1);
                    i--;
                }
            }

            scene.children.forEach(child => {
                if (child.userData.isRoad || child.userData.isLine) {
                    child.position.z += currentSpeed;
                    if (child.position.z > 15) {
                        child.position.z -= 180;
                    }
                }
                if (child.userData.isScenery || child.userData.isCloud || child.userData.isBuilding) {
                    child.position.z += currentSpeed * 0.5;
                    if (child.position.z > 50) {
                        child.position.z -= 200;
                    }
                }
            });

            updateParticles(delta);
            checkAchievements();
            updateHUD();

            // FIX: Add health depletion check to trigger Game Over
            if (health <= 0) {
                endGame(false, 'health_depleted');
                return; 
            }
        }

        function collectItem(item) {
            item.userData.collected = true;
            const type = item.userData.type;
            const itemData = ITEM_TYPES[type];
            const healthChange = itemData.health;

            health = Math.max(0, Math.min(100, health + healthChange));

            if (healthChange < 0) {
                badStreak++;
                goodStreak = 0;
                combo = 0;
                
                // --- START: Limited Mouth Growth (REQUEST 1) ---
                player.userData.mouthScale = Math.min(MAX_MOUTH_SCALE, player.userData.mouthScale + MOUTH_GROWTH_RATE_PER_BAD_ITEM);
                // --- END: Limited Mouth Growth ---

                createParticleExplosion(item.position.x, item.position.y, item.position.z, false);
                screenShake();
                flashScreen();
            } else {
                badStreak = 0;
                goodStreak++;
                combo++;
                maxCombo = Math.max(maxCombo, combo);

                const comboBonus = combo * 5;
                score += itemData.points + comboBonus;

                player.userData.mouthScale = Math.max(1, player.userData.mouthScale - 0.25);

                createParticleExplosion(item.position.x, item.position.y, item.position.z, true);

                if (combo >= 3 && combo % 3 === 0) {
                    showCombo(combo);
                }
            }

            // Scale the mouth with original proportions
            player.userData.mouth.scale.set(
                player.userData.mouthScale * 1.2,
                player.userData.mouthScale * 0.5,
                player.userData.mouthScale * 0.6
            );

            item.scale.set(0, 0, 0);

            // MODIFIED: Check against the new BAD_STREAK_LIMIT
            if (badStreak >= BAD_STREAK_LIMIT) {
                endGame(false, 'cancer');
            }
        }

        function updateHUD() {
            document.getElementById('timer').textContent = Math.ceil(gameTime) + 's';
            document.getElementById('score').textContent = score;
            document.getElementById('combo').textContent = combo + 'x';

            const healthEl = document.getElementById('health');
            healthEl.textContent = Math.round(health) + '%';

            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = health + '%';

            healthEl.className = '';
            healthBar.className = 'health-bar';
            if (health >= 70) {
                healthEl.classList.add('health-good');
            } else if (health >= 40) {
                healthEl.classList.add('health-warning');
                healthBar.classList.add('warning');
            } else {
                healthEl.classList.add('health-bad');
                healthBar.classList.add('bad');
            }

            // MODIFIED: Display 0/3 instead of 0/5
            document.getElementById('streak').textContent = badStreak + '/' + BAD_STREAK_LIMIT;
        }

        function startGame() {
            console.log('Starting game...');
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');
            document.getElementById('catalogue-toggle').classList.remove('hidden');

            gameRunning = true;
            health = 100;
            badStreak = 0;
            goodStreak = 0;
            combo = 0;
            maxCombo = 0;
            score = 0;
            gameTime = 0;
            currentLane = 1;
            lastSpawnTime = 0;
            achievements = [];
            SPAWN_INTERVAL = baseSpawnInterval;

            player.position.x = 0;
            player.userData.mouthScale = 1;
            player.userData.mouth.scale.set(1.2, 0.5, 0.6);

            items.forEach(item => scene.remove(item));
            items = [];

            particles.forEach(p => scene.remove(p));
            particles = [];

            updateHUD();
        }

        function endGame(survived, reason) {
            gameRunning = false;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('catalogue-toggle').classList.add('hidden');
            document.getElementById('catalogue-panel').classList.add('hidden');

            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            if (reason === 'cancer') {
                title.textContent = 'üò¢ Oral Cancer Developed';
                title.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                title.style.webkitBackgroundClip = 'text';
                title.style.webkitTextFillColor = 'transparent';
                // MODIFIED: Update message to reflect the new limit
                message.textContent = `You consumed ${BAD_STREAK_LIMIT} harmful items in a row. Smoking and poor diet significantly increase oral cancer risk!`;
            } else if (reason === 'health_depleted') {
                // FIX: New reason for health falling to zero
                title.textContent = 'üíî Health Depleted!';
                title.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                title.style.webkitBackgroundClip = 'text';
                title.style.webkitTextFillColor = 'transparent';
                message.textContent = 'Your oral health dropped to zero! Remember to balance your diet and avoid major risks like smoking.';
            } 
             else if (survived) {
                title.textContent = 'üéâ You Survived!';
                title.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                title.style.webkitBackgroundClip = 'text';
                title.style.webkitTextFillColor = 'transparent';
                message.textContent = 'Great job! Keep choosing healthy foods and avoiding tobacco to reduce cancer risk.';
            } else {
                title.textContent = '‚è∞ Time\'s Up!';
                title.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                title.style.webkitBackgroundClip = 'text';
                title.style.webkitTextFillColor = 'transparent';
                message.textContent = health >= 50
                    ? 'You finished, but watch your oral health!'
                    : 'Poor oral health! Remember: smoking and junk food increase cancer risk.';
            }

            document.getElementById('finalHealth').textContent = Math.round(health) + '%';
            document.getElementById('finalHealth').className =
                health >= 70 ? 'health-good' : health >= 40 ? 'health-warning' : 'health-bad';

            document.getElementById('finalScore').textContent = score;
            document.getElementById('maxCombo').textContent = maxCombo + 'x';

            // Show achievements
            const achievementsEl = document.getElementById('achievements');
            if (achievements.length > 0) {
                achievementsEl.innerHTML = '<h3 style="margin-bottom: 12px;">üèÜ Achievements Unlocked!</h3>';
                achievementsEl.innerHTML += achievements.map(id => {
                    const ach = ACHIEVEMENTS_LIST.find(a => a.id === id);
                    return `<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); padding: 12px; border-radius: 8px; margin: 8px 0; border: 2px solid #f59e0b;">
                        <strong>${ach.name}</strong><br>
                        <small>${ach.desc}</small>
                    </div>`;
                }).join('');
            } else {
                achievementsEl.innerHTML = '';
            }
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        }

        let lastTime = 0;
        function animate(time = 0) {
            requestAnimationFrame(animate);
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            updateGame(delta);
            renderer.render(scene, camera);
        }

        window.onload = () => {
            init3D();
        };
    </script>
</body>
</html>